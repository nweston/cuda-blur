// Pre-compute weights for direct convolution blurs.

#include <iostream>

void box_filter(float *dest, float *source, int center, int radius) {
  for (int i = radius; i <= 90; i++) {
    float sum = 0;
    for (int j = i - radius; j <= i + radius; j++) {
      sum += source[j];
    }
    dest[i] = sum / (2.0f * radius + 1);
  }
}

int main() {
  const int MAX_RADIUS = 30;

  std::cout << "////// Pre-computed weights for Gaussian blur /////\n"
            << "// Generated by compute-weights.cxx.\n\n"
            << "const int MAX_PRECOMPUTED_RADIUS = " << MAX_RADIUS << ";\n";
  for (int radius = 1; radius <= MAX_RADIUS; radius++) {
    // Start with a unit impulse and box filter it three times.
    // Use big arrays so we don't have to worry about boundary conditions.
    float weights[101] = {0.0f};
    float temp1[101] = {0.0f};
    float temp2[101] = {0.0f};
    weights[50] = 1.0f;

    int remaining = radius;
    int r = radius / 3;
    box_filter(temp1, weights, 50, r);

    remaining -= r;
    r = remaining / 2;
    box_filter(temp2, temp1, 50, r);

    r = remaining - r;
    box_filter(weights, temp2, 50, r);

    // Find the sum of all weights
    float sum = 0;
    for (int i = 50 - radius; i <= 50 + radius; i++) {
      sum += weights[i];
    }

    // Print out the weights from the center to the edge of the blur
    std::cout << "__constant__ float weights" << std::to_string(radius)
              << "[] = {";
    for (int i = 50; i <= 50 + radius; i++) {
      std::cout << weights[i] / sum << ", ";
    }
    std::cout << "};\n";
  }
  std::cout << "__constant__ float* weights[] = {nullptr, ";
  for (int radius = 1; radius <= MAX_RADIUS; radius++) {
    std::cout << "weights" << std::to_string(radius) << ", ";
  }
  std::cout << "};\n";

  std::cout << "////// End pre-computed weights /////\n";

  return 0;
}
